"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProxyAgent = void 0;
const error_1 = require("@pnpm/error");
const https_proxy_agent_1 = require("https-proxy-agent");
const http_proxy_agent_1 = require("http-proxy-agent");
const socks_proxy_agent_1 = require("socks-proxy-agent");
const lru_cache_1 = __importDefault(require("lru-cache"));
const DEFAULT_MAX_SOCKETS = 50;
const AGENT_CACHE = new lru_cache_1.default({ max: 50 });
function getProxyAgent(uri, opts) {
    const parsedUri = new URL(uri);
    const pxuri = getProxyUri(parsedUri, opts);
    if (!pxuri)
        return;
    const isHttps = parsedUri.protocol === 'https:';
    /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
    const key = [
        `https:${isHttps.toString()}`,
        `proxy:${pxuri.protocol}//${pxuri.username}:${pxuri.password}@${pxuri.host}:${pxuri.port}`,
        `local-address:${opts.localAddress ?? '>no-local-address<'}`,
        `strict-ssl:${isHttps ? Boolean(opts.strictSsl).toString() : '>no-strict-ssl<'}`,
        `ca:${(isHttps && opts.ca?.toString()) || '>no-ca<'}`,
        `cert:${(isHttps && opts.cert?.toString()) || '>no-cert<'}`,
        `key:${(isHttps && opts.key) || '>no-key<'}`,
    ].join(':');
    /* eslint-enable @typescript-eslint/prefer-nullish-coalescing */
    if (AGENT_CACHE.peek(key)) {
        return AGENT_CACHE.get(key);
    }
    const proxy = getProxy(pxuri, opts, isHttps);
    AGENT_CACHE.set(key, proxy);
    return proxy;
}
exports.getProxyAgent = getProxyAgent;
function getProxyUri(uri, opts) {
    const { protocol } = uri;
    let proxy;
    switch (protocol) {
        case 'http:': {
            proxy = opts.httpProxy;
            break;
        }
        case 'https:': {
            proxy = opts.httpsProxy;
            break;
        }
    }
    if (!proxy) {
        return undefined;
    }
    if (!proxy.includes('://')) {
        proxy = `${protocol}//${proxy}`;
    }
    if (typeof proxy !== 'string') {
        return proxy;
    }
    try {
        return new URL(proxy);
    }
    catch (err) {
        throw new error_1.PnpmError('INVALID_PROXY', "Couldn't parse proxy URL", {
            hint: `If your proxy URL contains a username and password, make sure to URL-encode them (you may use the encodeURIComponent function). For instance, https-proxy=https://use%21r:pas%2As@my.proxy:1234/foo. Do not encode the colon (:) between the username and password.`,
        });
    }
}
function getProxy(proxyUrl, opts, isHttps) {
    const popts = {
        auth: getAuth(proxyUrl),
        ca: opts.ca,
        cert: opts.cert,
        key: opts.key,
        localAddress: opts.localAddress,
        maxSockets: opts.maxSockets ?? DEFAULT_MAX_SOCKETS,
        rejectUnauthorized: opts.strictSsl,
        timeout: typeof opts.timeout !== 'number' || opts.timeout === 0
            ? 0
            : opts.timeout + 1,
    };
    if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {
        if (!isHttps) {
            return new http_proxy_agent_1.HttpProxyAgent(proxyUrl, popts);
        }
        else {
            return new PatchedHttpsProxyAgent(proxyUrl, popts);
        }
    }
    if (proxyUrl.protocol?.startsWith('socks')) {
        return new socks_proxy_agent_1.SocksProxyAgent(proxyUrl, popts);
    }
    return undefined;
}
function getAuth(user) {
    if (!user.username) {
        return undefined;
    }
    let auth = user.username;
    if (user.password) {
        auth += `:${user.password}`;
    }
    return decodeURIComponent(auth);
}
const extraOpts = Symbol('extra agent opts');
// This is a workaround for this issue: https://github.com/TooTallNate/node-https-proxy-agent/issues/89
class PatchedHttpsProxyAgent extends https_proxy_agent_1.HttpsProxyAgent {
    constructor(proxyUrl, opts) {
        super(proxyUrl, opts);
        this[extraOpts] = opts;
    }
    connect(req, opts) {
        return super.connect(req, { ...this[extraOpts], ...opts });
    }
}
//# sourceMappingURL=proxy-agent.js.map
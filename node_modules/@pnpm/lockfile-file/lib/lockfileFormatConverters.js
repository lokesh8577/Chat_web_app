"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertLockfileV9ToLockfileObject = exports.convertToLockfileObject = exports.convertToLockfileFile = void 0;
const dependency_path_1 = require("@pnpm/dependency-path");
const git_resolver_1 = require("@pnpm/git-resolver");
const types_1 = require("@pnpm/types");
const equals_1 = __importDefault(require("ramda/src/equals"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const map_1 = __importDefault(require("ramda/src/map"));
const omit_1 = __importDefault(require("ramda/src/omit"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const pick_1 = __importDefault(require("ramda/src/pick"));
const constants_1 = require("@pnpm/constants");
function convertToLockfileFile(lockfile, opts) {
    const packages = {};
    const snapshots = {};
    for (const [depPath, pkg] of Object.entries(lockfile.packages ?? {})) {
        snapshots[depPath] = (0, pick_1.default)([
            'dependencies',
            'optionalDependencies',
            'transitivePeerDependencies',
            'optional',
            'id',
        ], pkg);
        const pkgId = (0, dependency_path_1.removeSuffix)(depPath);
        if (!packages[pkgId]) {
            packages[pkgId] = (0, pick_1.default)([
                'bundledDependencies',
                'cpu',
                'deprecated',
                'engines',
                'hasBin',
                'libc',
                'name',
                'os',
                'peerDependencies',
                'peerDependenciesMeta',
                'resolution',
                'version',
            ], pkg);
        }
    }
    const newLockfile = {
        ...lockfile,
        snapshots,
        packages,
        lockfileVersion: constants_1.LOCKFILE_VERSION,
        importers: mapValues(lockfile.importers, convertProjectSnapshotToInlineSpecifiersFormat),
    };
    if (newLockfile.settings?.peersSuffixMaxLength === 1000) {
        newLockfile.settings = (0, omit_1.default)(['peersSuffixMaxLength'], newLockfile.settings);
    }
    return normalizeLockfile(newLockfile, opts);
}
exports.convertToLockfileFile = convertToLockfileFile;
function normalizeLockfile(lockfile, opts) {
    let lockfileToSave;
    if (!opts.forceSharedFormat && (0, equals_1.default)(Object.keys(lockfile.importers ?? {}), ['.'])) {
        lockfileToSave = {
            ...lockfile,
            ...lockfile.importers?.['.'],
        };
        delete lockfileToSave.importers;
        for (const depType of types_1.DEPENDENCIES_FIELDS) {
            if ((0, isEmpty_1.default)(lockfileToSave[depType])) {
                delete lockfileToSave[depType];
            }
        }
        if ((0, isEmpty_1.default)(lockfileToSave.packages) || (lockfileToSave.packages == null)) {
            delete lockfileToSave.packages;
        }
        if ((0, isEmpty_1.default)(lockfileToSave.snapshots) || (lockfileToSave.snapshots == null)) {
            delete lockfileToSave.snapshots;
        }
    }
    else {
        lockfileToSave = {
            ...lockfile,
            importers: (0, map_1.default)((importer) => {
                const normalizedImporter = {};
                if (importer.dependenciesMeta != null && !(0, isEmpty_1.default)(importer.dependenciesMeta)) {
                    normalizedImporter.dependenciesMeta = importer.dependenciesMeta;
                }
                for (const depType of types_1.DEPENDENCIES_FIELDS) {
                    if (!(0, isEmpty_1.default)(importer[depType] ?? {})) {
                        normalizedImporter[depType] = importer[depType];
                    }
                }
                if (importer.publishDirectory) {
                    normalizedImporter.publishDirectory = importer.publishDirectory;
                }
                return normalizedImporter;
            }, lockfile.importers ?? {}),
        };
        if ((0, isEmpty_1.default)(lockfileToSave.packages) || (lockfileToSave.packages == null)) {
            delete lockfileToSave.packages;
        }
        if ((0, isEmpty_1.default)(lockfileToSave.snapshots) || (lockfileToSave.snapshots == null)) {
            delete lockfileToSave.snapshots;
        }
    }
    if (lockfileToSave.time) {
        lockfileToSave.time = pruneTimeInLockfileV6(lockfileToSave.time, lockfile.importers ?? {});
    }
    if ((lockfileToSave.catalogs != null) && (0, isEmpty_1.default)(lockfileToSave.catalogs)) {
        delete lockfileToSave.catalogs;
    }
    if ((lockfileToSave.overrides != null) && (0, isEmpty_1.default)(lockfileToSave.overrides)) {
        delete lockfileToSave.overrides;
    }
    if ((lockfileToSave.patchedDependencies != null) && (0, isEmpty_1.default)(lockfileToSave.patchedDependencies)) {
        delete lockfileToSave.patchedDependencies;
    }
    if (!lockfileToSave.packageExtensionsChecksum) {
        delete lockfileToSave.packageExtensionsChecksum;
    }
    if (!lockfileToSave.ignoredOptionalDependencies?.length) {
        delete lockfileToSave.ignoredOptionalDependencies;
    }
    if (!lockfileToSave.pnpmfileChecksum) {
        delete lockfileToSave.pnpmfileChecksum;
    }
    return lockfileToSave;
}
function pruneTimeInLockfileV6(time, importers) {
    const rootDepPaths = new Set();
    for (const importer of Object.values(importers)) {
        for (const depType of types_1.DEPENDENCIES_FIELDS) {
            for (const [depName, ref] of Object.entries(importer[depType] ?? {})) {
                const suffixStart = ref.version.indexOf('(');
                const refWithoutPeerSuffix = suffixStart === -1 ? ref.version : ref.version.slice(0, suffixStart);
                const depPath = refToRelative(refWithoutPeerSuffix, depName);
                if (!depPath)
                    continue;
                rootDepPaths.add(depPath);
            }
        }
    }
    return (0, pickBy_1.default)((_, depPath) => rootDepPaths.has(depPath), time);
}
function refToRelative(reference, pkgName) {
    if (reference.startsWith('link:')) {
        return null;
    }
    if (reference.startsWith('file:')) {
        return reference;
    }
    if (!reference.includes('/') || !reference.replace(/(\([^)]+\))+$/, '').includes('/')) {
        return `/${pkgName}@${reference}`;
    }
    return reference;
}
/**
 * Reverts changes from the "forceSharedFormat" write option if necessary.
 */
function convertFromLockfileFileMutable(lockfileFile) {
    if (typeof lockfileFile?.['importers'] === 'undefined') {
        lockfileFile.importers = {
            '.': {
                dependenciesMeta: lockfileFile['dependenciesMeta'],
                publishDirectory: lockfileFile['publishDirectory'],
            },
        };
        for (const depType of types_1.DEPENDENCIES_FIELDS) {
            if (lockfileFile[depType] != null) {
                lockfileFile.importers['.'][depType] = lockfileFile[depType];
                delete lockfileFile[depType];
            }
        }
    }
    return lockfileFile;
}
function convertToLockfileObject(lockfile) {
    if (lockfile.snapshots) {
        return convertLockfileV9ToLockfileObject(lockfile);
    }
    convertPkgIds(lockfile);
    const { importers, ...rest } = convertFromLockfileFileMutable(lockfile);
    const newLockfile = {
        ...rest,
        importers: mapValues(importers ?? {}, revertProjectSnapshot),
    };
    return newLockfile;
}
exports.convertToLockfileObject = convertToLockfileObject;
function convertPkgIds(lockfile) {
    const oldIdToNewId = {};
    if (lockfile.packages == null || (0, isEmpty_1.default)(lockfile.packages))
        return;
    for (const [pkgId, pkg] of Object.entries(lockfile.packages ?? {})) {
        if (pkg.name) {
            const { id, peersSuffix } = (0, dependency_path_1.parseDepPath)(pkgId);
            let newId = `${pkg.name}@`;
            if ('tarball' in pkg.resolution) {
                newId += pkg.resolution.tarball;
                if (pkg.resolution.path) {
                    newId += `#path:${pkg.resolution.path}`;
                }
            }
            else if ('repo' in pkg.resolution) {
                newId += (0, git_resolver_1.createGitHostedPkgId)(pkg.resolution);
            }
            else if ('directory' in pkg.resolution) {
                newId += id;
            }
            else {
                continue;
            }
            oldIdToNewId[pkgId] = `${newId}${peersSuffix}`;
            if (id !== pkgId) {
                oldIdToNewId[id] = newId;
            }
        }
        else {
            const { id, peersSuffix } = (0, dependency_path_1.parseDepPath)(pkgId);
            const newId = id.substring(1);
            oldIdToNewId[pkgId] = `${newId}${peersSuffix}`;
            if (id !== pkgId) {
                oldIdToNewId[id] = newId;
            }
        }
    }
    const newLockfilePackages = {};
    for (const [pkgId, pkg] of Object.entries(lockfile.packages ?? {})) {
        if (oldIdToNewId[pkgId]) {
            if (pkg.id) {
                pkg.id = oldIdToNewId[pkg.id];
            }
            newLockfilePackages[oldIdToNewId[pkgId]] = pkg;
        }
        else {
            newLockfilePackages[pkgId] = pkg;
        }
        for (const depType of ['dependencies', 'optionalDependencies']) {
            for (const [alias, depPath] of Object.entries(pkg[depType] ?? {})) {
                if (oldIdToNewId[depPath]) {
                    if (oldIdToNewId[depPath].startsWith(`${alias}@`)) {
                        pkg[depType][alias] = oldIdToNewId[depPath].substring(alias.length + 1);
                    }
                    else {
                        pkg[depType][alias] = oldIdToNewId[depPath];
                    }
                }
            }
        }
    }
    lockfile.packages = newLockfilePackages;
    if ((lockfile.dependencies != null || lockfile.devDependencies != null || lockfile.optionalDependencies != null) && !lockfile.importers?.['.']) {
        lockfile.importers = lockfile.importers ?? {};
        lockfile.importers['.'] = {
            dependencies: lockfile.dependencies,
            devDependencies: lockfile.devDependencies,
            optionalDependencies: lockfile.optionalDependencies,
        };
        delete lockfile.dependencies;
        delete lockfile.devDependencies;
        delete lockfile.optionalDependencies;
    }
    for (const importer of Object.values(lockfile.importers ?? {})) {
        for (const depType of ['dependencies', 'optionalDependencies', 'devDependencies']) {
            for (const [alias, { version }] of Object.entries(importer[depType] ?? {})) {
                if (oldIdToNewId[version]) {
                    if (oldIdToNewId[version].startsWith(`${alias}@`)) {
                        importer[depType][alias].version = oldIdToNewId[version].substring(alias.length + 1);
                    }
                    else {
                        importer[depType][alias].version = oldIdToNewId[version];
                    }
                }
            }
        }
    }
    for (const depType of ['dependencies', 'optionalDependencies', 'devDependencies']) {
        for (const [alias, { version }] of Object.entries(lockfile[depType] ?? {})) {
            if (oldIdToNewId[version]) {
                lockfile[depType][alias].version = oldIdToNewId[version];
            }
        }
    }
}
function convertLockfileV9ToLockfileObject(lockfile) {
    const { importers, ...rest } = convertFromLockfileFileMutable(lockfile);
    const packages = {};
    for (const [depPath, pkg] of Object.entries(lockfile.snapshots ?? {})) {
        const pkgId = (0, dependency_path_1.removeSuffix)(depPath);
        packages[depPath] = Object.assign(pkg, lockfile.packages?.[pkgId]);
    }
    return {
        ...(0, omit_1.default)(['snapshots'], rest),
        packages,
        importers: mapValues(importers ?? {}, revertProjectSnapshot),
    };
}
exports.convertLockfileV9ToLockfileObject = convertLockfileV9ToLockfileObject;
function convertProjectSnapshotToInlineSpecifiersFormat(projectSnapshot) {
    const { specifiers, ...rest } = projectSnapshot;
    if (specifiers == null)
        return projectSnapshot;
    const convertBlock = (block) => block != null
        ? convertResolvedDependenciesToInlineSpecifiersFormat(block, { specifiers })
        : block;
    return {
        ...rest,
        dependencies: convertBlock(projectSnapshot.dependencies ?? {}),
        optionalDependencies: convertBlock(projectSnapshot.optionalDependencies ?? {}),
        devDependencies: convertBlock(projectSnapshot.devDependencies ?? {}),
    };
}
function convertResolvedDependenciesToInlineSpecifiersFormat(resolvedDependencies, { specifiers }) {
    return mapValues(resolvedDependencies, (version, depName) => ({
        specifier: specifiers[depName],
        version,
    }));
}
function revertProjectSnapshot(from) {
    const specifiers = {};
    function moveSpecifiers(from) {
        const resolvedDependencies = {};
        for (const [depName, { specifier, version }] of Object.entries(from)) {
            const existingValue = specifiers[depName];
            if (existingValue != null && existingValue !== specifier) {
                throw new Error(`Project snapshot lists the same dependency more than once with conflicting versions: ${depName}`);
            }
            specifiers[depName] = specifier;
            resolvedDependencies[depName] = version;
        }
        return resolvedDependencies;
    }
    const dependencies = from.dependencies == null
        ? from.dependencies
        : moveSpecifiers(from.dependencies);
    const devDependencies = from.devDependencies == null
        ? from.devDependencies
        : moveSpecifiers(from.devDependencies);
    const optionalDependencies = from.optionalDependencies == null
        ? from.optionalDependencies
        : moveSpecifiers(from.optionalDependencies);
    return {
        ...from,
        specifiers,
        dependencies,
        devDependencies,
        optionalDependencies,
    };
}
function mapValues(obj, mapper) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        result[key] = mapper(value, key);
    }
    return result;
}
//# sourceMappingURL=lockfileFormatConverters.js.map
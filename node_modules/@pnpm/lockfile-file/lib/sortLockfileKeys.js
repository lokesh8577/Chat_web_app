"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortLockfileKeys = void 0;
const util_lex_comparator_1 = require("@pnpm/util.lex-comparator");
const sort_keys_1 = __importDefault(require("sort-keys"));
const ORDERED_KEYS = {
    resolution: 1,
    id: 2,
    name: 3,
    version: 4,
    engines: 5,
    cpu: 6,
    os: 7,
    libc: 8,
    deprecated: 9,
    hasBin: 10,
    prepare: 11,
    requiresBuild: 12,
    bundleDependencies: 13,
    peerDependencies: 14,
    peerDependenciesMeta: 15,
    dependencies: 16,
    optionalDependencies: 17,
    transitivePeerDependencies: 18,
    dev: 19,
    optional: 20,
};
const ROOT_KEYS = [
    'lockfileVersion',
    'settings',
    'catalogs',
    'overrides',
    'packageExtensionsChecksum',
    'pnpmfileChecksum',
    'patchedDependencies',
    'dependencies',
    'optionalDependencies',
    'devDependencies',
    'dependenciesMeta',
    'importers',
    'packages',
];
const ROOT_KEYS_ORDER = Object.fromEntries(ROOT_KEYS.map((key, index) => [key, index]));
function compareWithPriority(priority, left, right) {
    const leftPriority = priority[left];
    const rightPriority = priority[right];
    if (leftPriority != null && rightPriority != null)
        return leftPriority - rightPriority;
    if (leftPriority != null)
        return -1;
    if (rightPriority != null)
        return 1;
    return (0, util_lex_comparator_1.lexCompare)(left, right);
}
function sortLockfileKeys(lockfile) {
    const compareRootKeys = compareWithPriority.bind(null, ROOT_KEYS_ORDER);
    if (lockfile.importers != null) {
        lockfile.importers = (0, sort_keys_1.default)(lockfile.importers);
        for (const [importerId, importer] of Object.entries(lockfile.importers)) {
            lockfile.importers[importerId] = (0, sort_keys_1.default)(importer, {
                compare: compareRootKeys,
                deep: true,
            });
        }
    }
    if (lockfile.packages != null) {
        lockfile.packages = (0, sort_keys_1.default)(lockfile.packages);
        for (const [pkgId, pkg] of Object.entries(lockfile.packages)) {
            lockfile.packages[pkgId] = (0, sort_keys_1.default)(pkg, {
                compare: compareWithPriority.bind(null, ORDERED_KEYS),
                deep: true,
            });
        }
    }
    if (lockfile.snapshots != null) {
        lockfile.snapshots = (0, sort_keys_1.default)(lockfile.snapshots);
        for (const [pkgId, pkg] of Object.entries(lockfile.snapshots)) {
            lockfile.snapshots[pkgId] = (0, sort_keys_1.default)(pkg, {
                compare: compareWithPriority.bind(null, ORDERED_KEYS),
                deep: true,
            });
        }
    }
    if (lockfile.catalogs != null) {
        lockfile.catalogs = (0, sort_keys_1.default)(lockfile.catalogs);
        for (const [catalogName, catalog] of Object.entries(lockfile.catalogs)) {
            lockfile.catalogs[catalogName] = (0, sort_keys_1.default)(catalog, {
                compare: util_lex_comparator_1.lexCompare,
                deep: true,
            });
        }
    }
    for (const key of ['dependencies', 'devDependencies', 'optionalDependencies', 'time', 'patchedDependencies']) {
        if (!lockfile[key])
            continue;
        lockfile[key] = (0, sort_keys_1.default)(lockfile[key]); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    return (0, sort_keys_1.default)(lockfile, { compare: compareRootKeys });
}
exports.sortLockfileKeys = sortLockfileKeys;
//# sourceMappingURL=sortLockfileKeys.js.map